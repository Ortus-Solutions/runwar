import se.bjurr.gitchangelog.api.GitChangelogApi

import static se.bjurr.gitchangelog.api.GitChangelogApi.gitChangelogApiBuilder

plugins {
    id 'com.github.johnrengelman.shadow' version '4.0.2'
    id "com.diffplug.gradle.oomph.ide" version "3.17.1"
    id "se.bjurr.gitchangelog.git-changelog-gradle-plugin" version "1.55"
}

defaultTasks 'clean', 'shadow'

buildDir = file('dist')

apply plugin: 'java'

group = 'org.cfmlprojects'
description = 'RunWar Gradle build script'
archivesBaseName = 'runwar-legacy'
apply from: 'gradle/config.gradle'

sourceCompatibility = 1.8
targetCompatibility = 1.8
tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
    options.compilerArgs += '-Xlint:unchecked'
    options.compilerArgs += '-Xlint:deprecation'
}

wrapper{
    distributionType = Wrapper.DistributionType.ALL
    doLast{
        // customise gradlew for our JVM auto-download script
        def javaRelease = System.getenv( 'JVM_RELEASE' ) ?: 'latest'
        def javaMajorVersion = System.getenv( 'JVM_MAJOR_VERSION' ) ?: 11
        def javaDir = System.getenv( 'JVM_HOME' ) ?: "gradle/jvm/${javaMajorVersion}/latest"
        def envVars = "\nexport JVM_MAJOR_VERSION=${ javaMajorVersion }\nexport JVM_DIR=\"${ javaDir }\"\nexport JVM_RELEASE=${ javaRelease }\nexport GRADLE_USER_HOME=\"\${HOME}/.gradle\"\n"
        envVars += ". \"\${APP_HOME}/gradle/jvm-setup.sh\"\n"
        scriptFile.text = new StringBuilder( scriptFile.text ).insert( scriptFile.text.indexOf( 'APP_NAME' ) - 1, envVars )
    }
}

javadoc {
    options.addStringOption('Xdoclint:none', '-quiet')
}

tasks.withType(Test) {
}

sourceSets {
    main {
        output.dir(generatedResources, builtBy: 'generateVersionFile')
    }
}

test {
    // Enable JUnit 5 (Gradle 4.6+).
    useJUnitPlatform { /*jvmArgs "-verbose:class"*/ }

    // Always run tests, even when nothing changed.
    dependsOn 'cleanTest'

    // Show test results.
    testLogging { events "passed", "skipped", "failed" }

    // show standard out and standard error of the test JVM(s) on the console
    testLogging.showStandardStreams = true
}

// create an OSGI manifest
apply plugin: 'com.diffplug.gradle.osgi.bndmanifest'
osgiBndManifest { copyTo 'META-INF/MANIFEST.MF' }

jar {
    archiveClassifier = 'core'
    manifest.attributes(
            'Main-Class': 'runwar.Start',
            'Can-Redefine-Classes': 'true',
            'Automatic-Module-Name': 'runwar',
            'Can-Retransform-Classes': 'true',
            'Implementation-Version': project.version,
            '-exportcontents': 'runwar.*',
            '-removeheaders': 'Bnd-LastModified,Bundle-Name,Created-By,Tool,Private-Package,Require-Capability',
            'Import-Package': '!javax.annotation.*,*',
            'Bundle-SymbolicName': project.name,
            'Bundle-RequiredExecutionEnvironment': 'JavaSE-1.8',
            'Require-Capability': 'osgi.ee;filter:="(&(osgi.ee=JavaSE)(version=1.8))"',
            'Bundle-Vendor': 'cfmlprojects.org',
            'Bundle-License': "MIT"
    )
}

task javadocJar(type: Jar) {
    archiveClassifier = 'javadoc'
    from javadoc
}

task sourceJar(type: Jar) {
    archiveClassifier = 'sources'
    from sourceSets.main.allSource
}

shadowJar {
    archiveClassifier = null
    mergeServiceFiles()
    exclude('**/*.java')
    transform(com.github.jengelman.gradle.plugins.shadow.transformers.Log4j2PluginsCacheFileTransformer)
    manifest {
       attributes(
     	 "Multi-Release": true )
    }
}
apply from: 'gradle/proguard.gradle'
apply from: 'gradle/maven.gradle'

task copyToLib(type: Copy) {
    doFirst { delete "$buildDir/libs" }
    into "$buildDir/libs"
    from configurations.runtime
}

task gitChangelogTask() {
    doLast {
        GitChangelogApi builder;
        builder = gitChangelogApiBuilder()

        println builder.withFromRef("master-legacy")
                .withToRef("HEAD")
                .withGitHubApi("https://api.github.com/repos/Ortus-Solutions/runwar")
                .withRemoveIssueFromMessageArgument(false)
                .withUntaggedName("Untagged version")
                .withNoIssueName("These commits have no issue in their commit comment")
                .withTemplateContent("""
					# Changelog

					{{#tags}}
					## {{name}}
					 {{^hasIssue}}
					 GitHub Issues:
					 {{/hasIssue}}
					 {{#issues}}
					  {{#hasLink}}
					  [{{issue}}]({{link}}) {{title}}
					  {{#commits}}
					   [{{hash}}] {{{messageTitle}}} (https://github.com/{{ownerName}}/{{repoName}}/commit/{{hash}})
					  {{/commits}}
					  {{/hasLink}}
					 {{/issues}}

					 {{#issues}}
					  {{^hasLink}}
					 Commits:
					  {{#commits}}
					  [{{hash}}] {{{messageTitle}}} (https://github.com/{{ownerName}}/{{repoName}}/commit/{{hash}})
					  {{/commits}}
					  {{/hasLink}}
					 {{/issues}}

					{{/tags}}
                """.stripIndent())
                .render()

    }
}

task listUsedClasses() {
    doFirst {
        def verboseFilePath = file('/workspace/runwar/used.txt')
        TreeSet<String> usedJars = new TreeSet<>()
        TreeSet<String> usedClasses = new TreeSet<>(); TreeSet<String> duplicateEntries = new TreeSet<>()
        HashMap<String, String> mergedEntries = new HashMap<>()

        usedJars.clear()
        usedClasses.clear()
        verboseFilePath.eachLine { line ->
            int pos = line.indexOf("from file")
            if (pos < 0)
                return
            String jarName = line.substring(pos + 11, line.length() - 1)
            if (jarName.contains("/jre") || jarName.contains("\\jre") || !jarName.endsWith(".jar"))
                return
            usedJars.add(jarName)
            String className = line.substring(8, pos - 1)
            usedClasses.add(className)
        }
        usedJars.each { println "used jar ${it}" }
        usedClasses.each { println "keep 'class ${it}'" }
    }

}
